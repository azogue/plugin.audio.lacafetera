# -*- coding: utf-8 -*-import datetime as dtimport jsonimport osimport sysimport urllibimport urllib2import xbmcimport xbmcguiimport xbmcpluginfrom resources.libs.common_addon import Addon__addon_name__ = 'La Cafetera'__id__ = 'plugin.audio.lacafetera'__author__ = 'Azogue'ADDON_ID = __id__ENCODING = 'utf-8'addon = Addon(ADDON_ID, sys.argv)xbmcplugin.setContent(int(sys.argv[1]), 'episodes')xbmcplugin.setPluginCategory(int(sys.argv[1]), 'News')real_dirname = os.path.split(os.path.dirname(os.path.abspath(__file__)))[-1]FANART = xbmc.translatePath(os.path.join('special://home/addons/' + real_dirname, 'fanart.jpg'))ICON = xbmc.translatePath(os.path.join('special://home/addons/' + real_dirname, 'icon.png'))BASE_URL_V2 = 'https://api.spreaker.com/v2/'BASE_URL = 'http://api.spreaker.com/'DEFAULT_ITEMS_PAG = '/items?&max_per_page=50&page=1'NUM_EPISODES_PAGINATION = 10CAFETERA_SHOWID = 1060718CAFETERA_AUTHORID = 5647623DEFAULT_TRACK_INFO = {"Album": "La Cafetera (radiocable)", "Artist": "Fernando Berlín", "Rating": "5", "Genre": "News"}MODE_LIST_EPS = '19'MODE_LIVE = '3'MODE_SEARCH = '50'MODE_PLAY = '100'def _text(text, bold=True, color=''):    if color:        text = '[COLOR ' + color + ']' + text + '[/COLOR]'    if bold:        text = '[B]' + text + '[/B]'    return textdef _encode_obj(in_obj):    """Unicode, UTF-8 + python 2.7 nightmares. A dirty solution"""    def _encode_list(in_list):        out_list = []        for el in in_list:            out_list.append(_encode_obj(el))        return out_list    def _encode_dict(in_dict):        out_dict = {}        for k, v in in_dict.iteritems():            out_dict[k] = _encode_obj(v)        return out_dict    if isinstance(in_obj, unicode):        return in_obj.encode('utf-8')    elif isinstance(in_obj, list):        return _encode_list(in_obj)    elif isinstance(in_obj, tuple):        return tuple(_encode_list(in_obj))    elif isinstance(in_obj, dict):        return _encode_dict(in_obj)    return in_objdef _get_json_response(url_get_req):    """JSON GET request."""    # addon.log('URL JSON: ' + url_get_req)    req = urllib2.Request(url_get_req)    req.add_header('Content-Type', 'text/html; charset=utf-8')    response = urllib2.urlopen(req)    raw = response.read()    response.close()    if raw:        res_data = _encode_obj(json.loads(raw, encoding=ENCODING))        if 'response' in res_data:            return True, res_data['response']    return False, rawdef _url_info_ep_cafetera(ep_id):    return BASE_URL_V2 + 'episodes/' + str(ep_id)def _url_play_ep_cafetera(ep_id):    return BASE_URL + 'listen/episode/' + str(ep_id) + '/http'def _url_last_eps_cafetera(limit=1):    return BASE_URL_V2 + 'shows/' + str(CAFETERA_SHOWID) + '/episodes?limit=' + str(limit)def _url_search_eps_cafetera(search):    url_search = BASE_URL_V2 + 'search/shows/' + str(CAFETERA_SHOWID) + '?type=episodes&q='    return url_search + urllib.quote_plus(search) + '&limit=100'# def _make_url_eps_live():#     return BASE_URL + '/episodes/live'def _extract_ep_info_from_spreaker_api(data_ep):    """Extrae la información disponible en Spreaker API del episodio dado por ID."""    ep_id = data_ep['episode_id']    playurl = _url_play_ep_cafetera(ep_id)    ep_title = _encode_obj(data_ep['title'])    ep_thumbnail = _encode_obj(data_ep['image_original_url'])    ep_dur = data_ep['duration'] // 1000    ep_ts = _encode_obj(data_ep['published_at'])    dia, hora = ep_ts.split()    anyo, mes, dia = [int(x) for x in dia.split('-')]    hora, minute, seg = [int(x) for x in hora.split(':')]    ts = dt.datetime(year=anyo, month=mes, day=dia, hour=hora, minute=minute, second=seg)    # description = '%s. (%d:%d, %s)' % (str(ep_title), int(ep_dur // 60), round(ep_dur % 60), ep_ts)    info_params = {"Title": ep_title,                   'Year': anyo,                   # 'Lyrics': description,                   'Tracknumber': ts.timetuple().tm_yday,                   'Duration': ep_dur,                   'Date': ts.strftime('%d.%m.%Y')}    return ep_id, playurl, info_params, ep_thumbnaildef _make_kodi_item_from_ep(item_name, info_ep_spreaker=None, info_ep_search=None):    item_thumbnail = ICON    info_item = DEFAULT_TRACK_INFO.copy()    if info_ep_spreaker is not None:        _, playurl, info_params, item_thumbnail = _extract_ep_info_from_spreaker_api(info_ep_spreaker['episode'])        info_item.update(**info_params)    elif info_ep_search is not None:        item_thumbnail = info_ep_search.pop('thumbnail')        info_item.update(**info_ep_search)    item_menu = xbmcgui.ListItem(item_name, iconImage=item_thumbnail, thumbnailImage=item_thumbnail)    item_menu.setInfo(type="music", infoLabels=info_item)    item_menu.setProperty('mimetype', 'audio/mpeg')    item_menu.setArt({'fanart': FANART})    return item_menudef append_item_to_list(item_name, item_url=None, gui_mode=None,                        thumbnail=ICON, ep_id=None, **kwargs_info_item):    """Añade un item al GUI del AddOn; puede ser un directorio o un item reproducible."""    def _make_kodi_menu_item():        item_menu = xbmcgui.ListItem(item_name, iconImage=thumbnail, thumbnailImage=thumbnail)        item_menu.setArt({'fanart': FANART})        return item_menu    url_u = sys.argv[0]    if item_url is not None:        url_u += "?url=" + urllib.quote_plus(item_url)        if gui_mode is not None:            url_u += "&mode=" + str(gui_mode)        if ep_id is not None:            url_u += "&ep_id=" + str(ep_id)    if ep_id is None:  # item menu -> link        item_list = _make_kodi_menu_item()        is_folder = True    else:  # item menu -> episode        is_folder = False        kwargs_info_item['thumbnail'] = thumbnail        item_list = _make_kodi_item_from_ep(item_name, info_ep_search=kwargs_info_item)    return xbmcplugin.addDirectoryItem(handle=int(sys.argv[1]), url=url_u, listitem=item_list, isFolder=is_folder)def append_items_list_end(is_search_result=False, next_url=None, is_empty_list=False):    """Añade items al final de los submenús."""    if is_search_result:        if is_empty_list:            append_item_to_list('SIN RESULTADOS')            append_item_to_list(_text('Lo intentamos otra vez?', color='gold'), 'url', MODE_SEARCH)        else:            append_item_to_list(_text('Buscamos otra cosa?', color='gold'), 'url', MODE_SEARCH)    elif next_url is not None:        append_item_to_list(_text('Más antiguos >>', color='gold'), next_url, MODE_LIST_EPS)    append_item_to_list(_text('>> Índice', color='blue'))def get_last_episode():    """Obtiene el último episodio disponible."""    url_last = _url_last_eps_cafetera(1)    ok, resp_eps = _get_json_response(url_last)    if ok:        ep = resp_eps['items'][0]        ep_id, playurl, info_params, ep_thumbnail = _extract_ep_info_from_spreaker_api(ep)        last_episode = {'id': ep_id, 'play_url': playurl, 'params': info_params, 'thumbnail': ep_thumbnail}        return last_episode    return Nonedef addon_index():    """Addon Main menu."""    last = get_last_episode()    n_eps = NUM_EPISODES_PAGINATION    label_next = _text('Últimos ' + str(n_eps) + ' episodios', color='gold')    if last is not None:        label = _text('Último: **', bold=False, color='blue')        label += _text(last['params']['Title'], color='orange')        label += _text('**', bold=False, color='blue')        append_item_to_list(label, last['play_url'], MODE_PLAY, last['thumbnail'], ep_id=last['id'], **last['params'])    append_item_to_list(label_next, _url_last_eps_cafetera(n_eps), MODE_LIST_EPS)    append_item_to_list(_text('Busca episodios ...', color='gold'), 'url', MODE_SEARCH)    # append_item_to_list(_text('En directo', color='darkviolet'), _make_url_eps_live(), MODE_LIVE)def addon_list_eps_cafetera(url_list_eps, is_search_result=False):    """Recoge episodios de La Cafetera mediante la url de búsqueda y los añade al menú"""    algun_ep, next_url = False, None    ok, resp_eps = _get_json_response(url_list_eps)    if ok:        next_url = str(resp_eps['next_url'])        for ep in resp_eps['items']:            ep_id, playurl, info_params, ep_thumbnail = _extract_ep_info_from_spreaker_api(ep)            append_item_to_list(info_params['Title'], playurl, MODE_PLAY, ep_thumbnail, ep_id=ep_id, **info_params)            algun_ep = True    append_items_list_end(is_search_result, next_url=next_url, is_empty_list=not algun_ep)def addon_search_eps_cafetera():    """Lanza cuadro de diálogo para buscar episodios por texto incluido en el nombre."""    search_entered = ''    keyboard = xbmc.Keyboard(search_entered, 'Introduce texto para buscar en el nombre del episodio (¡usa tildes!):')    keyboard.doModal()    if keyboard.isConfirmed():        search_entered = keyboard.getText().replace(' ', '+')    if (search_entered is None) or (len(search_entered) < 1):        append_items_list_end(True, is_empty_list=True)    else:        url_search = _url_search_eps_cafetera(search_entered)        addon_list_eps_cafetera(url_search, is_search_result=True)def addon_play_ep_cafetera(url_play, ep_id):    """Reproduce episodio de La Cafetera."""    playlist = xbmc.PlayList(1)    playlist.clear()    # addon.log('PLAY: ' + str(_url_info_ep_cafetera(ep_id)))    ok, info_ep = _get_json_response(_url_info_ep_cafetera(ep_id))    item = _make_kodi_item_from_ep('...', info_ep_spreaker=info_ep if ok else None)    playlist.add(url_play, item)    player = xbmc.Player()    player.play(playlist)# def open_url(url_):#     # TODO rehacer con json vs re!#     req = urllib2.Request(url_)#     req.add_header('User-Agent',#                    'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')#     response = urllib2.urlopen(req)##     link = response.read()#     response.close()#     return link### def addon_play_live_stream(url_live):#     # TODO aquí fallará#     link = open_url(url_live)#     match = re.compile('"episode_id":(.+?),.+?"title":"(.+?)".+?"site_url":"(.+?)".+?"play_url":"(.+?)"',#                        re.DOTALL).findall(link)#     for episode, name, _url, thumb in match:#         # url = url.replace('\/', '/')#         # thumb = thumb.replace('\/', '/')#         name2 = name.decode("ascii", "ignore").replace('&amp;#039;', '').replace('\u266b ', '').replace('\u266b',#                                                                                                         '')#         playurl = _url_play_ep_cafetera(episode)#         append_item_to_list(name2, playurl, MODE_PLAY, ep_id='4691191')# MAIN LOGIC:def _get_params():    """Get parameters from `sys.argv[2]`."""    def _clean_param(d_params, key):        if key in d_params.keys():            return urllib.unquote_plus(d_params[key])        return None    d_param = {}    paramstring = sys.argv[2]    if len(paramstring) >= 2:        paramstring = paramstring.lstrip('?')        for p in paramstring.split('&'):            param = p.split('=')            if len(param) == 2:                d_param[param[0]] = param[1]    return tuple([_clean_param(d_param, k) for k in ('mode', 'url', 'ep_id')])mode, url, episode_id = _get_params()if (mode is None) or (url is None) or (len(url) < 1):    addon_index()elif mode == MODE_LIST_EPS:    addon_list_eps_cafetera(url, is_search_result=False)elif mode == MODE_SEARCH:    addon_search_eps_cafetera()elif mode == MODE_PLAY:    addon_play_ep_cafetera(url, episode_id)# TODO Hacer live mode# elif mode == MODE_LIVE:#     addon_play_live_stream(url)else:    addon.log_error('WTF? mode=' + mode)xbmcplugin.endOfDirectory(int(sys.argv[1]))