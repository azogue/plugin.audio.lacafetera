# -*- coding: utf-8 -*-import datetime as dtimport jsonimport osimport sysimport urllibimport urllib2import urlparseimport xbmcimport xbmcguiimport xbmcpluginfrom resources.libs.common_addon import AddonADDON_ID = 'plugin.audio.lacafetera'addon = Addon(ADDON_ID, sys.argv)__id__ = addon.get_id()__addon_name__ = addon.get_name()__author__ = addon.get_author()__version__ = addon.get_version()base_path = addon.get_path()FANART = os.path.join(base_path, 'fanart.jpg')ICON = os.path.join(base_path, 'icon.png')url_base_addon = sys.argv[0]addon_handle = int(sys.argv[1])addon_args = urlparse.parse_qs(sys.argv[2][1:])xbmcplugin.setContent(addon_handle, 'audio')  # 'episodes'xbmcplugin.setPluginCategory(addon_handle, 'News')BASE_URL_V2 = 'https://api.spreaker.com/v2/'BASE_URL = 'http://api.spreaker.com/'CAFETERA_SHOWID = 1060718CAFETERA_AUTHORID = 5647623ENCODING = 'utf-8'DEFAULT_ITEMS_PAG = '/items?&max_per_page=50&page=1'NUM_EPISODES_PAGINATION = 10DEFAULT_TRACK_INFO = {"Album": "La Cafetera (radiocable)", "Artist": "Fernando Berlín", "Rating": "5", "Genre": "News"}MODE_LIST_EPS = 'listeps'MODE_SEARCH = 'search'MODE_PLAY = 'play'MODE_PLAYLAST = 'playlast'def _text(text, bold=True, color=''):    if color:        text = '[COLOR ' + color + ']' + text + '[/COLOR]'    if bold:        text = '[B]' + text + '[/B]'    return textdef _encode_obj(in_obj):    """Unicode, UTF-8 + python 2.7 nightmares. A dirty solution"""    def _encode_list(in_list):        out_list = []        for el in in_list:            out_list.append(_encode_obj(el))        return out_list    def _encode_dict(in_dict):        out_dict = {}        for k, v in in_dict.iteritems():            out_dict[k] = _encode_obj(v)        return out_dict    if isinstance(in_obj, unicode):        return in_obj.encode(ENCODING)    elif isinstance(in_obj, list):        return _encode_list(in_obj)    elif isinstance(in_obj, tuple):        return tuple(_encode_list(in_obj))    elif isinstance(in_obj, dict):        return _encode_dict(in_obj)    return in_objdef _get_json_response(url_get_req):    """JSON GET request."""    req = urllib2.Request(url_get_req)    req.add_header('Content-Type', 'text/html; charset=' + ENCODING)    response = urllib2.urlopen(req)    raw = response.read()    response.close()    if raw:        res_data = _encode_obj(json.loads(raw, encoding=ENCODING))        if 'response' in res_data:            return True, res_data['response']    return False, rawdef _url_info_ep_cafetera(ep_id):    return BASE_URL_V2 + 'episodes/' + str(ep_id)def _url_play_ep_cafetera(ep_id):    return BASE_URL + 'listen/episode/' + str(ep_id) + '/http'def _url_last_eps_cafetera(limit=1):    return BASE_URL_V2 + 'shows/' + str(CAFETERA_SHOWID) + '/episodes?limit=' + str(limit)def _url_search_eps_cafetera(search):    url_search = BASE_URL_V2 + 'search/shows/' + str(CAFETERA_SHOWID) + '?type=episodes&q='    return url_search + urllib.quote_plus(search) + '&limit=100'def _extract_ep_info_from_spreaker_api(data_ep):    """Extrae la información disponible en Spreaker API del episodio dado por ID.    :param data_ep: episode data    :type data_ep: dict    :return: is_live_stream, episode_id, url_episode_thumbnail, url_play, info_params_episode    :rtype: tuple    """    ep_id = data_ep['episode_id']    playurl = _url_play_ep_cafetera(ep_id)    ep_title = _encode_obj(data_ep['title'])    ep_thumbnail = _encode_obj(data_ep['image_original_url'])    ep_ts = _encode_obj(data_ep['published_at'])    dia, hora = ep_ts.split()    anyo, mes, dia = [int(x) for x in dia.split('-')]    hora, minute, seg = [int(x) for x in hora.split(':')]    ts = dt.datetime(year=anyo, month=mes, day=dia, hour=hora, minute=minute, second=seg)    # description = '%s. (%d:%d, %s)' % (str(ep_title), int(ep_dur // 60), round(ep_dur % 60), ep_ts)    info_params = {"Title": ep_title,                   'Year': anyo,                   # 'Lyrics': description,                   'Tracknumber': ts.timetuple().tm_yday,                   'Date': ts.strftime('%d.%m.%Y')}    if data_ep["type"] == "LIVE":  # "is_on_air": true, "is_non_stop": false        return True, ep_id, ep_thumbnail, playurl, info_params    else:        info_params.update({'Duration': data_ep['duration'] // 1000})        return False, ep_id, ep_thumbnail, playurl, info_paramsdef _make_kodi_item_from_ep(item_name, info_ep_spreaker=None, info_ep_search=None):    item_thumbnail = ICON    info_item = DEFAULT_TRACK_INFO.copy()    if info_ep_spreaker is not None:        is_live, _, item_thumbnail, playurl, params = _extract_ep_info_from_spreaker_api(info_ep_spreaker['episode'])        if is_live:            item_name = 'DIRECTO: ' + item_name        info_item.update(**params)    elif info_ep_search is not None:        item_thumbnail = info_ep_search.pop('thumbnail')        info_item.update(**info_ep_search)    item_menu = xbmcgui.ListItem(item_name, iconImage=item_thumbnail, thumbnailImage=item_thumbnail)    item_menu.setInfo(type="music", infoLabels=info_item)    item_menu.setProperty('mimetype', 'audio/mp3')    item_menu.setArt({'fanart': FANART})    return item_menudef append_item_to_list(item_name, item_url=None, gui_mode=None,                        thumbnail=ICON, ep_id=None, **kwargs_info_item):    """Añade un item al GUI del AddOn; puede ser un directorio o un item reproducible."""    def _make_kodi_menu_item():        item_menu = xbmcgui.ListItem(item_name, iconImage=thumbnail, thumbnailImage=thumbnail)        item_menu.setArt({'fanart': FANART})        return item_menu    url_u = url_base_addon    if item_url is not None:        url_u += "?url=" + urllib.quote_plus(item_url)        if gui_mode is not None:            url_u += "&mode=" + str(gui_mode)        if ep_id is not None:            url_u += "&ep_id=" + str(ep_id)    if ep_id is None:  # item menu -> link        item_list = _make_kodi_menu_item()        is_folder = True    else:  # item menu -> episode        is_folder = False        kwargs_info_item['thumbnail'] = thumbnail        item_list = _make_kodi_item_from_ep(item_name, info_ep_search=kwargs_info_item)    return xbmcplugin.addDirectoryItem(handle=addon_handle, url=url_u, listitem=item_list, isFolder=is_folder)def append_items_list_end(is_search_result=False, next_url=None, is_empty_list=False):    """Añade items al final de los submenús."""    if is_search_result:        if is_empty_list:            append_item_to_list('SIN RESULTADOS')            append_item_to_list(_text('Lo intentamos otra vez?', color='gold'), 'url', MODE_SEARCH)        else:            append_item_to_list(_text('Buscamos otra cosa?', color='gold'), 'url', MODE_SEARCH)    elif next_url is not None:        append_item_to_list(_text('Más antiguos >>', color='gold'), next_url, MODE_LIST_EPS)    append_item_to_list(_text('>> Índice', color='blue'))def get_last_episode():    """Obtiene el último episodio disponible."""    url_last = _url_last_eps_cafetera(1)    ok, resp_eps = _get_json_response(url_last)    if ok:        ep = resp_eps['items'][0]        is_live, ep_id, ep_thumbnail, playurl, info_params = _extract_ep_info_from_spreaker_api(ep)        if is_live:            color_title = 'red'  # 'darkviolet'            label = _text('DIRECTO: **', bold=True, color='blue')        else:            color_title = 'orange'            label = _text('Último: **', bold=False, color='blue')        label += _text(info_params['Title'], color=color_title)        label += _text('**', bold=is_live, color='blue')        last_episode = {'id': ep_id, 'play_url': playurl, 'params': info_params, 'thumbnail': ep_thumbnail}        return is_live, label, last_episode    return False, None, Nonedef addon_index():    """Addon Main menu."""    n_eps = NUM_EPISODES_PAGINATION    label_next = _text('Últimos ' + str(n_eps) + ' episodios', color='gold')    _is_live_stream, title, last = get_last_episode()    if last is not None:        append_item_to_list(title, last['play_url'], MODE_PLAY, last['thumbnail'], ep_id=last['id'], **last['params'])    append_item_to_list(label_next, _url_last_eps_cafetera(n_eps), MODE_LIST_EPS)    append_item_to_list(_text('Busca episodios ...', color='gold'), 'url', MODE_SEARCH)def addon_list_eps_cafetera(url_list_eps, is_search_result=False):    """Recoge episodios de La Cafetera mediante la url de búsqueda y los añade al menú"""    algun_ep, next_url = False, None    ok, resp_eps = _get_json_response(url_list_eps)    if ok:        next_url = str(resp_eps['next_url'])        for ep in resp_eps['items']:            is_live_stream, ep_id, ep_thumbnail, playurl, info_params = _extract_ep_info_from_spreaker_api(ep)            append_item_to_list(info_params['Title'], playurl, MODE_PLAY, ep_thumbnail, ep_id=ep_id, **info_params)            algun_ep = True    append_items_list_end(is_search_result, next_url=next_url, is_empty_list=not algun_ep)def addon_search_eps_cafetera():    """Lanza cuadro de diálogo para buscar episodios por texto incluido en el nombre."""    search_entered = ''    keyboard = xbmc.Keyboard(search_entered, 'Introduce texto para buscar en el nombre del episodio (¡usa tildes!):')    keyboard.doModal()    if keyboard.isConfirmed():        search_entered = keyboard.getText().replace(' ', '+')    if (search_entered is None) or (len(search_entered) < 1):        append_items_list_end(True, is_empty_list=True)    else:        url_search = _url_search_eps_cafetera(search_entered)        addon_list_eps_cafetera(url_search, is_search_result=True)def addon_play_ep_cafetera(url_play, ep_id):    """Reproduce episodio de La Cafetera en pantalla completa."""    ok, info_ep = _get_json_response(_url_info_ep_cafetera(ep_id))    item = _make_kodi_item_from_ep(info_ep['episode']['title'] if ok else 'ERROR',                                   info_ep_spreaker=info_ep if ok else None)    player = xbmc.Player()    player.play(url_play, item)    xbmc.executebuiltin('Action(FullScreen)')def main():    """Lógica general del add-on"""    mode, url, episode_id = [addon_args.get(k, [None])[0] for k in ('mode', 'url', 'ep_id')]    if mode is None:        addon_index()    elif mode == MODE_LIST_EPS:        addon_list_eps_cafetera(url, is_search_result=False)    elif mode == MODE_SEARCH:        addon_search_eps_cafetera()    elif mode == MODE_PLAY:        addon_play_ep_cafetera(url, episode_id)    elif mode == MODE_PLAYLAST:        _live_stream, _label, last_episode = get_last_episode()        addon_index()        if last_episode is not None:            addon_play_ep_cafetera(last_episode['play_url'], last_episode['id'])    else:        addon.log_error('WTF? mode=' + str(mode))    xbmcplugin.endOfDirectory(addon_handle)if __name__ == '__main__':    main()